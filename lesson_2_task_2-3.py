"""
Дан список:
['в', '5', 'часов', '17', 'минут', 'температура', 'воздуха', 'была', '+5', 'градусов']
Необходимо его обработать — обособить каждое целое число (вещественные не трогаем) кавычками
(добавить кавычку до и кавычку после элемента списка, являющегося числом)
и дополнить нулём до двух целочисленных разрядов:
['в', '"', '05', '"', 'часов', '"', '17', '"', 'минут', 'температура', 'воздуха', 'была', '"', '+05', '"', 'градусов']
Сформировать из обработанного списка строку:
в "05" часов "17" минут температура воздуха была "+05" градусов
Подумать, какое условие записать, чтобы выявить числа среди элементов списка?
Как модифицировать это условие для чисел со знаком?
Примечание: если обособление чисел кавычками не будет получаться - можете вернуться к его реализации позже.
Главное: дополнить числа до двух разрядов нулём!

*(вместо задачи 2) Решить задачу 2 не создавая новый список (как говорят, in place).
Эта задача намного серьёзнее, чем может сначала показаться.
"""
# делал сразу усложненное

start_arr = ['в', '5', 'часов', '17', 'минут', 'температура', 'воздуха', 'была', '+5', 'градусов']
# start_arr = ['в', '100', 'gg', '1', '0', 'часов', '17', 'минут', 'температура', 'воздуха', 'была', '1', 'градусов']
# start_arr = ['в', '5', 'часов', '+5', '17', '--', '+-']

# мне казалось, что правильнее переменные объявлять в начале файла, если знаешь что будешь их использовать
# но задумался, для маленьких файлов это может и норм, но в больших без толковой ide сиди ищи где она там объявлена
# наверно правильнее переменные объявлять непосредственно перед скриптом, который будет ей заниматься?
# в моем случае это следующий блок
my_str = ''

print(f'Стартовый массив {start_arr}')

# у меня нет ощущения прекрасного от такой реализации со срезами
# но как сделать по другому запись нескольких значений
# по определенному индексу, не зависая в массиве, я не придумал
# был бы рад услышать как это можно сделать "правильно"
for i in reversed(range(len(start_arr))):
    if any(char.isdigit() for char in start_arr[i]):
        if start_arr[i].startswith('+') or start_arr[i].startswith('-'):
            start_arr[i:i + 1] = '"', start_arr[i][0] + f'{int(start_arr[i]):02d}', '"'
        else:
            start_arr[i:i + 1] = '"', f'{int(start_arr[i]):02d}', '"'

# аналог предыдущего блока
# одна из последних более мнее адекватных реализаций, которую я решил сохранить в назадание
# мега критичный недостаток, который обнаружил почти перед отправкой
# если будут 2 одинаковых значения ключа, т.е. 2 одинаковых числа, то второму не поставятся кавычки
# а первый окажется с двумя парами кавычек
# for value in reversed(start_arr):
#     key = start_arr.index(value)
#
#     if any(char.isdigit() for char in value):
#         if value.startswith('+') or value.startswith('-'):
#             start_arr[key:key + 1] = '"', value[0] + f'{int(value):02d}', '"'
#         else:
#             start_arr[key:key + 1] = '"',  f'{int(value):02d}', '"'

print(f'Обработанный массив {start_arr}')

for i in range(len(start_arr)):
    if any(char.isdigit() for char in start_arr[i]):
        # проверка если строка еще пустая, что = первому слову
        # то вставляем без пробела
        if len(my_str) == 0:
            my_str += f'"{start_arr[i]}"'
        else:
            my_str += f' "{start_arr[i]}"'
    elif start_arr[i] != '"' and i == 0:
        my_str += f'{start_arr[i]}'
    elif start_arr[i] != '"':
        my_str += f' {start_arr[i]}'

print(f'Строка из обработанного массива: {my_str}')
